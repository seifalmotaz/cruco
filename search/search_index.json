{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","tags":["cruky","dart","api","API"],"text":"cruky cruky is a server-side library for the dart ecosystem to help you create your API as fast as possible. Cruky team want to make server-side apps with modern style and fast high performance . The main reason why cruky was built, because all libraries are focused on the Flutter ecosystem and not on dart language and this makes the library have fewer futures than other frameworks or libraries like (Django, FastAPI, ROR, ..etc) So cruky team decided that we will make a new library that focuses on Dart and get the maximum performance using dart mirrors and code generators together to get the best usage of the dart. If you have any idea tell me in discussion section on github Submit new idea Inspired by server-side frameworks like (Django, Flask, FastAPI) Pub : https://pub.dev/packages/cruky Source Code : https://github.com/seifalmotaz/cruky Issues : https://github.com/seifalmotaz/cruky/issues Requirements Install Dart from Dart.dev run dart pub global activate cruky to install cruky executable create project by running cruky create appName Note if you run cruky and get bash: cruky: command not found error you can do this: try to run cruky.bat create appName if it did not work add C:\\Users\\{{Your name}}\\AppData\\Local\\Pub\\Cache\\bin to your enviroment variables First lines First we must define our main app or the server entry point that have all the routes we use in the app as Cruky recommend to name it MyApp bin/main.dart import 'package:cruky/cruky.dart' ; class MyApp extends ServerApp { @override List get routes => []; @override List get pipeline => []; } We can define two main things the routes getter and pipeline getter: routes used to add the route methods for the app middlewares used to add global middleware for the routes inside this app Second we can add some routes to the main app, we will create a route that response with json and contains a massege: bin/main.dart // rest of code @Route . get ( '/' ) Json getData ( Request req ) { return Json ({ 'msg' : \"Hello world\" }); /// You can use text response too like this Text(\"Hello world\") } We define an annotation first that contains the path then we add a method that handles the request and have a argument called req this argument has type Request that will help you get the request data easily like the (json, form, multipart/form) Now we must add this method to the main app inside the routes getter: bin/main.dart // rest of code class MyApp extends ServerApp { @override List get routes => [ getData , ]; @override List get pipeline => []; } // rest of code Last thing add the main function that will run the app: bin/main.dart void main () => runApp ( MyApp ()); // rest of code Now run the app with command dart pub run cruky serve or you can run dart run --enable-vm-service --disable-service-auth-codes bin/main.dart both are the same. this will run the app in debug mode with hot reload.","title":"Intro"},{"location":"#cruky","text":"cruky is a server-side library for the dart ecosystem to help you create your API as fast as possible. Cruky team want to make server-side apps with modern style and fast high performance . The main reason why cruky was built, because all libraries are focused on the Flutter ecosystem and not on dart language and this makes the library have fewer futures than other frameworks or libraries like (Django, FastAPI, ROR, ..etc) So cruky team decided that we will make a new library that focuses on Dart and get the maximum performance using dart mirrors and code generators together to get the best usage of the dart. If you have any idea tell me in discussion section on github Submit new idea Inspired by server-side frameworks like (Django, Flask, FastAPI) Pub : https://pub.dev/packages/cruky Source Code : https://github.com/seifalmotaz/cruky Issues : https://github.com/seifalmotaz/cruky/issues","title":"cruky"},{"location":"#requirements","text":"Install Dart from Dart.dev run dart pub global activate cruky to install cruky executable create project by running cruky create appName Note if you run cruky and get bash: cruky: command not found error you can do this: try to run cruky.bat create appName if it did not work add C:\\Users\\{{Your name}}\\AppData\\Local\\Pub\\Cache\\bin to your enviroment variables","title":"Requirements"},{"location":"#first-lines","text":"First we must define our main app or the server entry point that have all the routes we use in the app as Cruky recommend to name it MyApp bin/main.dart import 'package:cruky/cruky.dart' ; class MyApp extends ServerApp { @override List get routes => []; @override List get pipeline => []; } We can define two main things the routes getter and pipeline getter: routes used to add the route methods for the app middlewares used to add global middleware for the routes inside this app Second we can add some routes to the main app, we will create a route that response with json and contains a massege: bin/main.dart // rest of code @Route . get ( '/' ) Json getData ( Request req ) { return Json ({ 'msg' : \"Hello world\" }); /// You can use text response too like this Text(\"Hello world\") } We define an annotation first that contains the path then we add a method that handles the request and have a argument called req this argument has type Request that will help you get the request data easily like the (json, form, multipart/form) Now we must add this method to the main app inside the routes getter: bin/main.dart // rest of code class MyApp extends ServerApp { @override List get routes => [ getData , ]; @override List get pipeline => []; } // rest of code Last thing add the main function that will run the app: bin/main.dart void main () => runApp ( MyApp ()); // rest of code Now run the app with command dart pub run cruky serve or you can run dart run --enable-vm-service --disable-service-auth-codes bin/main.dart both are the same. this will run the app in debug mode with hot reload.","title":"First lines"},{"location":"releasenotes/","text":"Release Notes This page has every realese notes for any release. 1.0.0 First stable release 0.12.5 Adding web sockets 0.12.0 Adding schema validator 0.11.5 enable init and onInit functions docs update 0.11.3 fixing InApp problem adding JsonHandler and TextHandler 0.11.2 Adding request body converter 0.11.0 better route handlers scanner Changes rename 'ReqCTX' to 'Request' rename 'BeforeMW' to 'UsePre' rename 'AfterMW' to 'UsePost' rename 'middlewares' to 'pipeline' changing routes tree system instead of of adding all function to routes stack the routes saved in stack with 'PathHandler' that contains spacific path and all handlers with this path and every handler has a method Deleted for now there is no indirect handlers and json, form or iForm handlers 0.9.0 Added InDirect routes with query and json types not recommended for now Remove remove the database plugins Updating The FormCTX and iFormCTX to handle repeated fields 0.8.5 Added FormCTX for encoded form content type request that only accept application/x-www-form-urlencoded iFormCTX for encoded form content type request that only accept multipart/form-data Redirect response Database integrations Plugins app Updates Updating cruky create command Better debug mode with production mode simulation 0.8.1 fixing cruky cli rename run method to runApp updating hotreload 0.8.0 adding content-type filtering option changing the handler types system and make it reuseable adding JsonCTX for json content type request that only accept application/json 0.7.1 fix hot reload bug adding create command adding some docs 0.7.0 Remove the cruky_cli Adding hot reload instead of auto reload adding ServerApp for the server settings adding multi threaded option with isolates in the release mode (Not in the debug mode) 0.6.0 Changing the library design","title":"Release Notes"},{"location":"releasenotes/#release-notes","text":"This page has every realese notes for any release.","title":"Release Notes"},{"location":"releasenotes/#100","text":"First stable release","title":"1.0.0"},{"location":"releasenotes/#0125","text":"Adding web sockets","title":"0.12.5"},{"location":"releasenotes/#0120","text":"Adding schema validator","title":"0.12.0"},{"location":"releasenotes/#0115","text":"enable init and onInit functions docs update","title":"0.11.5"},{"location":"releasenotes/#0113","text":"fixing InApp problem adding JsonHandler and TextHandler","title":"0.11.3"},{"location":"releasenotes/#0112","text":"Adding request body converter","title":"0.11.2"},{"location":"releasenotes/#0110","text":"better route handlers scanner","title":"0.11.0"},{"location":"releasenotes/#changes","text":"rename 'ReqCTX' to 'Request' rename 'BeforeMW' to 'UsePre' rename 'AfterMW' to 'UsePost' rename 'middlewares' to 'pipeline' changing routes tree system instead of of adding all function to routes stack the routes saved in stack with 'PathHandler' that contains spacific path and all handlers with this path and every handler has a method","title":"Changes"},{"location":"releasenotes/#deleted","text":"for now there is no indirect handlers and json, form or iForm handlers","title":"Deleted"},{"location":"releasenotes/#090","text":"","title":"0.9.0"},{"location":"releasenotes/#added","text":"InDirect routes with query and json types not recommended for now","title":"Added"},{"location":"releasenotes/#remove","text":"remove the database plugins","title":"Remove"},{"location":"releasenotes/#updating","text":"The FormCTX and iFormCTX to handle repeated fields","title":"Updating"},{"location":"releasenotes/#085","text":"","title":"0.8.5"},{"location":"releasenotes/#added_1","text":"FormCTX for encoded form content type request that only accept application/x-www-form-urlencoded iFormCTX for encoded form content type request that only accept multipart/form-data Redirect response Database integrations Plugins app","title":"Added"},{"location":"releasenotes/#updates","text":"Updating cruky create command Better debug mode with production mode simulation","title":"Updates"},{"location":"releasenotes/#081","text":"fixing cruky cli rename run method to runApp updating hotreload","title":"0.8.1"},{"location":"releasenotes/#080","text":"adding content-type filtering option changing the handler types system and make it reuseable adding JsonCTX for json content type request that only accept application/json","title":"0.8.0"},{"location":"releasenotes/#071","text":"fix hot reload bug adding create command adding some docs","title":"0.7.1"},{"location":"releasenotes/#070","text":"Remove the cruky_cli Adding hot reload instead of auto reload adding ServerApp for the server settings adding multi threaded option with isolates in the release mode (Not in the debug mode)","title":"0.7.0"},{"location":"releasenotes/#060","text":"Changing the library design","title":"0.6.0"},{"location":"roadmap/","text":"Roadmap This page will contain the todo list and tasks for developing cruky . The tasks will be up to date to know what cruky team had finished. Currently working on Static files handler Search request.uri.path by segmants Start server for multiple ServerApp Https support In Future Features will be added at an unspecified time and may not occur: External ORM library inspired by Prisma Server CRUD code generator inspired by ROR Auto generator OpenAPI/Swagger page inspired by FastAPI Auto client code generator from open API inspired by Serverpod Http 2 support","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"This page will contain the todo list and tasks for developing cruky . The tasks will be up to date to know what cruky team had finished.","title":"Roadmap"},{"location":"roadmap/#currently-working-on","text":"Static files handler Search request.uri.path by segmants Start server for multiple ServerApp Https support","title":"Currently working on"},{"location":"roadmap/#in-future","text":"Features will be added at an unspecified time and may not occur: External ORM library inspired by Prisma Server CRUD code generator inspired by ROR Auto generator OpenAPI/Swagger page inspired by FastAPI Auto client code generator from open API inspired by Serverpod Http 2 support","title":"In Future"},{"location":"tutorial/01-Appmatrial/","tags":["AppMaterial","pipeline","routes","app material"],"text":"AppMaterial AppMaterial is the main thing that runs the server, it contains the main things that every app needs. Getters Name Type Description prefix String this is a route path prefix that will be added as a prefix to all routes children. routes List here we can define all the method handlers and routes. you simply add the function that has the annotation Route and it will add it to the routes tree. pipeline List here you can add all your middleware to the app and it will be added to all children. Usage Let's make an example. first, we define a class that extends the AppMaterial interface and adds routes and the prefix getter with path \"/example\": class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => []; } Now try to add a new route to the route tree like: class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => [ getData ]; @Route . get ( '/' ) Json getData ( Request req ) { return Text ( \"Hello world\" ); } } Now you can add this app to the routes tree by adding it to the main entry app: import 'package:cruky/cruky.dart' ; void main () => runApp ( MyApp (), debug: true ); class MyApp extends ServerApp { @override List get routes => [ ExampleApp (), ]; } class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => [ example , ]; @Route . get ( '/main' ) Text example ( Request req ) { return Text ( \"Hello world\" ); } } And run the app with dart pub run cruky serve Try to go to localhost:5000/example/main and you will get the Hello world response. Cruky supports nested apps which means you can add an app to the ExampleApp routes and it will have the prefix /example/ and the child app prefix.","title":"AppMaterial"},{"location":"tutorial/01-Appmatrial/#appmaterial","text":"AppMaterial is the main thing that runs the server, it contains the main things that every app needs.","title":"AppMaterial"},{"location":"tutorial/01-Appmatrial/#getters","text":"Name Type Description prefix String this is a route path prefix that will be added as a prefix to all routes children. routes List here we can define all the method handlers and routes. you simply add the function that has the annotation Route and it will add it to the routes tree. pipeline List here you can add all your middleware to the app and it will be added to all children.","title":"Getters"},{"location":"tutorial/01-Appmatrial/#usage","text":"Let's make an example. first, we define a class that extends the AppMaterial interface and adds routes and the prefix getter with path \"/example\": class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => []; } Now try to add a new route to the route tree like: class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => [ getData ]; @Route . get ( '/' ) Json getData ( Request req ) { return Text ( \"Hello world\" ); } } Now you can add this app to the routes tree by adding it to the main entry app: import 'package:cruky/cruky.dart' ; void main () => runApp ( MyApp (), debug: true ); class MyApp extends ServerApp { @override List get routes => [ ExampleApp (), ]; } class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => [ example , ]; @Route . get ( '/main' ) Text example ( Request req ) { return Text ( \"Hello world\" ); } } And run the app with dart pub run cruky serve Try to go to localhost:5000/example/main and you will get the Hello world response. Cruky supports nested apps which means you can add an app to the ExampleApp routes and it will have the prefix /example/ and the child app prefix.","title":"Usage"},{"location":"tutorial/02-InApp/","tags":["InApp","routes","in app"],"text":"InApp InApp class helps you to add routes to the main app like the AppMaterieal but does not has a routes getter instead you write the route method inside the class. Example class ExampleApp extends InApp { @override String get prefix => '/example' ; @Route . get ( '/' ) getExample ( Request req ) { return Text ( 'InApp example' ); } } Getters Name Type Description prefix String this is a route path prefix that will be added as a prefix to all routes children. pipeline List here you can add all your middleware to the app and it will be added to all children.","title":"InApp"},{"location":"tutorial/02-InApp/#inapp","text":"InApp class helps you to add routes to the main app like the AppMaterieal but does not has a routes getter instead you write the route method inside the class.","title":"InApp"},{"location":"tutorial/02-InApp/#example","text":"class ExampleApp extends InApp { @override String get prefix => '/example' ; @Route . get ( '/' ) getExample ( Request req ) { return Text ( 'InApp example' ); } }","title":"Example"},{"location":"tutorial/02-InApp/#getters","text":"Name Type Description prefix String this is a route path prefix that will be added as a prefix to all routes children. pipeline List here you can add all your middleware to the app and it will be added to all children.","title":"Getters"},{"location":"tutorial/03-ServerApp/","tags":["ServerApp","route","server app","method handler"],"text":"ServerApp ServerApp is the main app that the server will get the routes and all things from it like (port, host, routes, middlewares, plugins). This class extends AppMaterial and have the same getters. Getters It has the same AppMaterial getter plus: Name Type Description port String you can define a custom port to use here the default is 5000 address String you can define a custom host to use here the default is 127.0.0.1 plugins List you can add plugins to the app Usage class MyApp extends ServerApp { int get port => 80 ; String get address => '0.0.0.0' ; @override List get routes => [ ExampleApp (), ]; }","title":"ServerApp"},{"location":"tutorial/03-ServerApp/#serverapp","text":"ServerApp is the main app that the server will get the routes and all things from it like (port, host, routes, middlewares, plugins). This class extends AppMaterial and have the same getters.","title":"ServerApp"},{"location":"tutorial/03-ServerApp/#getters","text":"It has the same AppMaterial getter plus: Name Type Description port String you can define a custom port to use here the default is 5000 address String you can define a custom host to use here the default is 127.0.0.1 plugins List you can add plugins to the app","title":"Getters"},{"location":"tutorial/03-ServerApp/#usage","text":"class MyApp extends ServerApp { int get port => 80 ; String get address => '0.0.0.0' ; @override List get routes => [ ExampleApp (), ]; }","title":"Usage"},{"location":"tutorial/04-Route%20Handlers/","tags":["Route","route","annotation","method handler"],"text":"Route Handlers Route handlers are functions/methods that handle the request with a specific path, and they can have middleware before it or after. You can respond with the Response class. Usage As we said the method must have a path to knowing what path this method handles so we define Route annotation for the method. Route annotation Main constructor The main constructor has two required arguments and two optional and all of them are positional arguments. const Route ( this . path , // define the method path this . methods , [ // define the accepted methods like \"PUT, POST\" this . middlewares = const [], // adding scoped middlwares this . accepted = const [], // adding the accepted content type request ]); Constructors Some constructors will help you save some time. Name Description get This is a constructor that defines a route with the \"GET\" method post defines a route with the \"POST\" method put defines a route with the \"PUT\" method delete defines a route with the \"DELETE\" method ws defines a route for WebSocket handler type Handler method There are several types of route handlers that you can use we will discuss the basic one on this page. After writing the annotation we define the method under it: @Route . get ( '/my/path' ) Json example ( Request req ) { return Json ({}); } As we saw we defined the handler method with path /my/path/ and it responds with Json class that extends Response class. From the req argument you can access some of the request helpers functions like: you can access the JSON body from the request if the request content type is application/json or you can get the form data if content type is application/x-www-form-urlencoded or can get multipart form data if the content type multipart/form-data you can also get the path query data req.query.get('field_name') , and path parameters req.path.get('field_name') and headers req.headerValue('field_name')","title":"Route Handlers"},{"location":"tutorial/04-Route%20Handlers/#route-handlers","text":"Route handlers are functions/methods that handle the request with a specific path, and they can have middleware before it or after. You can respond with the Response class.","title":"Route Handlers"},{"location":"tutorial/04-Route%20Handlers/#usage","text":"As we said the method must have a path to knowing what path this method handles so we define Route annotation for the method.","title":"Usage"},{"location":"tutorial/04-Route%20Handlers/#route-annotation","text":"","title":"Route annotation"},{"location":"tutorial/04-Route%20Handlers/#main-constructor","text":"The main constructor has two required arguments and two optional and all of them are positional arguments. const Route ( this . path , // define the method path this . methods , [ // define the accepted methods like \"PUT, POST\" this . middlewares = const [], // adding scoped middlwares this . accepted = const [], // adding the accepted content type request ]);","title":"Main constructor"},{"location":"tutorial/04-Route%20Handlers/#constructors","text":"Some constructors will help you save some time. Name Description get This is a constructor that defines a route with the \"GET\" method post defines a route with the \"POST\" method put defines a route with the \"PUT\" method delete defines a route with the \"DELETE\" method ws defines a route for WebSocket handler type","title":"Constructors"},{"location":"tutorial/04-Route%20Handlers/#handler-method","text":"There are several types of route handlers that you can use we will discuss the basic one on this page. After writing the annotation we define the method under it: @Route . get ( '/my/path' ) Json example ( Request req ) { return Json ({}); } As we saw we defined the handler method with path /my/path/ and it responds with Json class that extends Response class. From the req argument you can access some of the request helpers functions like: you can access the JSON body from the request if the request content type is application/json or you can get the form data if content type is application/x-www-form-urlencoded or can get multipart form data if the content type multipart/form-data you can also get the path query data req.query.get('field_name') , and path parameters req.path.get('field_name') and headers req.headerValue('field_name')","title":"Handler method"},{"location":"tutorial/05-Path%20Params/","tags":["path","parameters","path type"],"text":"Path Parameters You can declare path parameters in the Route path string: @Route . get ( '/my/:id' ) Json example ( Request req ) { String myId = req . path [ 'id' ]; return Json ({ 'id' : myId }); } By adding : and the name of the parameter like :id or :name . you can get the parameter data from the path variable in request req.path['parameter'] . Types You can get a specific type of parameter by adding a type validator to the path parameter: @Route . get ( '/my/:id(int)' ) Json example ( Request req ) { int myId = req . path [ 'id' ]; return Json ({ 'id' : myId }); } The default type is a string but there are other types like int , double , num , and string . Note if you set a type for path parameter like the above example if anyone tries to send a request to /my/string will get 404 massage.","title":"Path Parameters"},{"location":"tutorial/05-Path%20Params/#path-parameters","text":"You can declare path parameters in the Route path string: @Route . get ( '/my/:id' ) Json example ( Request req ) { String myId = req . path [ 'id' ]; return Json ({ 'id' : myId }); } By adding : and the name of the parameter like :id or :name . you can get the parameter data from the path variable in request req.path['parameter'] .","title":"Path Parameters"},{"location":"tutorial/05-Path%20Params/#types","text":"You can get a specific type of parameter by adding a type validator to the path parameter: @Route . get ( '/my/:id(int)' ) Json example ( Request req ) { int myId = req . path [ 'id' ]; return Json ({ 'id' : myId }); } The default type is a string but there are other types like int , double , num , and string . Note if you set a type for path parameter like the above example if anyone tries to send a request to /my/string will get 404 massage.","title":"Types"},{"location":"tutorial/06-%20Request%20Body/","tags":["request","body","content type"],"text":"Request Body You can get the request data by the Request class, it will help you to manipulate the HttpRequest . Json json Request help you to convert the data to Map or List type: @Route . get ( '/' ) Future < Json > example ( Request req ) async { Map body = await req . json (); return Json ( body ); } Info It uses utf8 to decode HttpRequest stream. Form x-www-form-urlencoded @Route . get ( '/' ) Future < Text > example ( Request req ) async { FormData body = await req . form (); print ( body [ 'data' ]) // print List<String> print ( body . getInt ( 'data' )) // print int print ( body . listInt ( 'data' )) // print List<int> return Text ( 'ok' ); } This method will help you to get the form data as Map<String, List<String>> so you can get the data by body['data'] bu if you want to get the data with spacific type like int you can use body.getInt('data') or you can get a list of int by body.listInt('data') . Multipart form multipart/form-data It has the same options that in FormData and formFiles variable that contains a list of FilePart : @Route . get ( '/' ) Future < Text > example ( Request req ) async { iFormData body = await req . iForm (); print ( body . formFiles ); // print Map<String, List<FilePart>> print ( body [ 'data' ]) // print List<String> print ( body . getInt ( 'data' )) // print int print ( body . listInt ( 'data' )) // print List<int> print ( body [ 'file' ]) // print List<FilePart> print ( body . getFile ( 'file' )) // print FilePart return Text ( 'ok' ); }","title":"Request Body"},{"location":"tutorial/06-%20Request%20Body/#request-body","text":"You can get the request data by the Request class, it will help you to manipulate the HttpRequest .","title":"Request Body"},{"location":"tutorial/06-%20Request%20Body/#json-json","text":"Request help you to convert the data to Map or List type: @Route . get ( '/' ) Future < Json > example ( Request req ) async { Map body = await req . json (); return Json ( body ); } Info It uses utf8 to decode HttpRequest stream.","title":"Json json"},{"location":"tutorial/06-%20Request%20Body/#form-x-www-form-urlencoded","text":"@Route . get ( '/' ) Future < Text > example ( Request req ) async { FormData body = await req . form (); print ( body [ 'data' ]) // print List<String> print ( body . getInt ( 'data' )) // print int print ( body . listInt ( 'data' )) // print List<int> return Text ( 'ok' ); } This method will help you to get the form data as Map<String, List<String>> so you can get the data by body['data'] bu if you want to get the data with spacific type like int you can use body.getInt('data') or you can get a list of int by body.listInt('data') .","title":"Form x-www-form-urlencoded"},{"location":"tutorial/06-%20Request%20Body/#multipart-form-multipartform-data","text":"It has the same options that in FormData and formFiles variable that contains a list of FilePart : @Route . get ( '/' ) Future < Text > example ( Request req ) async { iFormData body = await req . iForm (); print ( body . formFiles ); // print Map<String, List<FilePart>> print ( body [ 'data' ]) // print List<String> print ( body . getInt ( 'data' )) // print int print ( body . listInt ( 'data' )) // print List<int> print ( body [ 'file' ]) // print List<FilePart> print ( body . getFile ( 'file' )) // print FilePart return Text ( 'ok' ); }","title":"Multipart form multipart/form-data"},{"location":"tutorial/07-Schema%20Validator/","tags":["schema","validator"],"text":"Schema Validator Cruky has a schema validator option that can help you get the data from the request body and make sure that the data sent is in the correct spelling: class Todo { String task ; bool isCompleted ; Todo ( this . task , this . isCompleted ); } To turn this class into a schema we must add a Schema annotation to define from where to get this data and add a parse constructor: @Schema . json () class Todo { final String task ; final bool isCompleted ; Todo . parse ( this . task , this . isCompleted ); } and add it to the route handler: @Route . get ( '/' ) Map example ( Request req , Todo todo ) { return { \"task\" : todo . task , \"is_completed\" : todo . isCompleted , }; } It will get the JSON body data and accept only the application/json content type. Note You can only have one schema validator for this handler type. Do not forget to add the parse constructor. In the parse constructor cruky accept both positioned and named arguments.","title":"Schema Validator"},{"location":"tutorial/07-Schema%20Validator/#schema-validator","text":"Cruky has a schema validator option that can help you get the data from the request body and make sure that the data sent is in the correct spelling: class Todo { String task ; bool isCompleted ; Todo ( this . task , this . isCompleted ); } To turn this class into a schema we must add a Schema annotation to define from where to get this data and add a parse constructor: @Schema . json () class Todo { final String task ; final bool isCompleted ; Todo . parse ( this . task , this . isCompleted ); } and add it to the route handler: @Route . get ( '/' ) Map example ( Request req , Todo todo ) { return { \"task\" : todo . task , \"is_completed\" : todo . isCompleted , }; } It will get the JSON body data and accept only the application/json content type. Note You can only have one schema validator for this handler type. Do not forget to add the parse constructor. In the parse constructor cruky accept both positioned and named arguments.","title":"Schema Validator"},{"location":"tutorial/08-Route%20Handlers%20Types/","tags":["methods","handlers"],"text":"Route Handlers Types Handler Type is a template for a method/function that will be executed as a handler for the route, Example: DirectHandler is the main method handler type that we had used until now, And the template looks like this: dynamic methodName ( Request req ) { return \"\" ; } As we see the method can return any type of data and have one argument of Request . If you changed the template to: dynamic methodName ( Request req , data ) { return \"\" ; } This method will not be a type of DirectHandler because the DirectHandler has a specific argument that cannot be removed or add any other argument. DirectHandler The first and the main handler type is the DirectHandler and the infrastructure: Return Type Method Args Content Type Dynamic Request Any JsonHandler A handler made specific for JSON content type request that will convert the request to Map type and pass it to the method. Return Type Method Args Content Type Dynamic Map JSON TextHandler A handler made specific for text content type request that will convert the request to String and pass it to the method. Return Type Method Args Content Type Dynamic String Almost Any Note The handler will convert the request to text using utf8 and pass it to the method. The handler can accept any content type request that can be converted to String . SchemaHandler We have discussed this handler before in Schema Validator . Return Type Method Args Content Type Dynamic Request , Schama class As Schema annotation accept Danger In the Method Args column the args in the method have the same order of args.","title":"Route Handlers Types"},{"location":"tutorial/08-Route%20Handlers%20Types/#route-handlers-types","text":"Handler Type is a template for a method/function that will be executed as a handler for the route, Example: DirectHandler is the main method handler type that we had used until now, And the template looks like this: dynamic methodName ( Request req ) { return \"\" ; } As we see the method can return any type of data and have one argument of Request . If you changed the template to: dynamic methodName ( Request req , data ) { return \"\" ; } This method will not be a type of DirectHandler because the DirectHandler has a specific argument that cannot be removed or add any other argument.","title":"Route Handlers Types"},{"location":"tutorial/08-Route%20Handlers%20Types/#directhandler","text":"The first and the main handler type is the DirectHandler and the infrastructure: Return Type Method Args Content Type Dynamic Request Any","title":"DirectHandler"},{"location":"tutorial/08-Route%20Handlers%20Types/#jsonhandler","text":"A handler made specific for JSON content type request that will convert the request to Map type and pass it to the method. Return Type Method Args Content Type Dynamic Map JSON","title":"JsonHandler"},{"location":"tutorial/08-Route%20Handlers%20Types/#texthandler","text":"A handler made specific for text content type request that will convert the request to String and pass it to the method. Return Type Method Args Content Type Dynamic String Almost Any Note The handler will convert the request to text using utf8 and pass it to the method. The handler can accept any content type request that can be converted to String .","title":"TextHandler"},{"location":"tutorial/08-Route%20Handlers%20Types/#schemahandler","text":"We have discussed this handler before in Schema Validator . Return Type Method Args Content Type Dynamic Request , Schama class As Schema annotation accept Danger In the Method Args column the args in the method have the same order of args.","title":"SchemaHandler"},{"location":"tutorial/09-WebSockets/","tags":["methods","handlers"],"text":"Web Sockets WebSockets are one of many different tools for building web applications that provide instant, real-time updates, and communication. The WebSocket Protocol establishes full-duplex, bidirectional communication between a client and server. Google search To use a web socket we use WebSocketHandler , It's one of the Route Handlers Type . Return Type Method Args Content Type Void WebSocket None Example import 'dart:io' ; @Route . ws ( '/' ) void example ( WebSocket socket ) { // you can use Future<void> for async method // listen to data from the socket socket . listen (( event ) { print ( event ); if ( event == 'close' ) { // send data socket . add ( \"Server is closing the socket\" ); // close the socket socket . close (); } }); } Danger The middleware after That have UsePre annotation the main method will not be executed.","title":"Web Sockets"},{"location":"tutorial/09-WebSockets/#web-sockets","text":"WebSockets are one of many different tools for building web applications that provide instant, real-time updates, and communication. The WebSocket Protocol establishes full-duplex, bidirectional communication between a client and server. Google search To use a web socket we use WebSocketHandler , It's one of the Route Handlers Type . Return Type Method Args Content Type Void WebSocket None","title":"Web Sockets"},{"location":"tutorial/09-WebSockets/#example","text":"import 'dart:io' ; @Route . ws ( '/' ) void example ( WebSocket socket ) { // you can use Future<void> for async method // listen to data from the socket socket . listen (( event ) { print ( event ); if ( event == 'close' ) { // send data socket . add ( \"Server is closing the socket\" ); // close the socket socket . close (); } }); } Danger The middleware after That have UsePre annotation the main method will not be executed.","title":"Example"},{"location":"tutorial/10-Isolates/","tags":["methods","handlers"],"text":"Isolates You can run the app in multiple isolates to have faster performance. We have two concepts: Isolates That means running the server app on 2 or more isolates and every isolate runs the same app. For more on Concurrency in Dart Listeners When cruky starts the server for an app it uses the HttpServer.bind method and starts listening to the requests. We can have multiple listeners for the same app in a single isolate. For more on HttpServer class Example void main () => runApp ( MyApp (), isolates: 2 , // run in two isolate listeners: 3 , // start 2 listeners ); class MyApp extends ServerApp { @override List get routes => [ example , ExampleApp (), ]; } In this example, we used isolates and listeners. This code run the app in two isolates and in every isolate starts three listeners.","title":"Isolates"},{"location":"tutorial/10-Isolates/#isolates","text":"You can run the app in multiple isolates to have faster performance. We have two concepts:","title":"Isolates"},{"location":"tutorial/10-Isolates/#isolates_1","text":"That means running the server app on 2 or more isolates and every isolate runs the same app. For more on Concurrency in Dart","title":"Isolates"},{"location":"tutorial/10-Isolates/#listeners","text":"When cruky starts the server for an app it uses the HttpServer.bind method and starts listening to the requests. We can have multiple listeners for the same app in a single isolate. For more on HttpServer class","title":"Listeners"},{"location":"tutorial/10-Isolates/#example","text":"void main () => runApp ( MyApp (), isolates: 2 , // run in two isolate listeners: 3 , // start 2 listeners ); class MyApp extends ServerApp { @override List get routes => [ example , ExampleApp (), ]; } In this example, we used isolates and listeners. This code run the app in two isolates and in every isolate starts three listeners.","title":"Example"}]}