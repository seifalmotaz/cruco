{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","tags":["cruky","dart","api","API"],"text":"Cruky Cruky is a server-side library for the dart ecosystem to help you create your API as fast as possible. Cruky team want to make server-side apps with modern style and fast high performance . The main reason why Cruky was built, because all libraries are focused on the Flutter ecosystem and not on dart language and this makes the library have fewer futures than other frameworks or libraries like (Django, FastAPI, ROR, ..etc) So cruky team decided that we will make a new library that focuses on Dart and get the maximum performance using dart mirrors and code generators together to get the best usage of the dart. If you have any idea tell me in discussion section on github Submit new idea Inspired by server-side frameworks like (Django, Flask, FastAPI) Note This is an early release of Cruky. there may be minor changes in future updates. A few features are still missing that will be part of the 1.0 release. Pub : https://pub.dev/packages/cruky Documentation : https://seifalmotaz.github.io/cruky/ Source Code : https://github.com/seifalmotaz/cruky Issues : https://github.com/seifalmotaz/cruky/issues Requirements Install Dart from Dart.dev run dart pub global activate cruky to install cruky executable create project by running cruky create appName Note: if you run cruky and get bash: cruky: command not found error you can do this: try to run cruky.bat create appName if it did not work add C:\\Users\\{{Your name}}\\AppData\\Local\\Pub\\Cache\\bin to your enviroment variables First lines First we must define our main app or the server entry point that have all the routes we use in the app as Cruky recommend to name it MyApp bin/main.dart import 'package:cruky/cruky.dart' ; class MyApp extends ServerApp { @override List get routes => []; @override List get pipeline => []; } We can define two main things the routes getter and pipeline getter: routes used to add the route methods for the app middlewares used to add global middleware for the routes inside this app Second we can add some routes to the main app, we will create a route that response with json and contains a massege: bin/main.dart // rest of code @Route . get ( '/' ) Json getData ( Request req ) { return Json ({ 'msg' : \"Hello world\" }); /// You can use text response too like this Text(\"Hello world\") } We define an annotation first that contains the path then we add a method that handles the request and have a argument called req this argument has type Request that will help you get the request data easily like the (json, form, multipart/form) Now we must add this method to the main app inside the routes getter: bin/main.dart // rest of code class MyApp extends ServerApp { @override List get routes => [ getData , ]; @override List get pipeline => []; } // rest of code Last thing add the main function that will run the app: bin/main.dart void main () => runApp ( MyApp ()); // rest of code Now run the app with command dart pub run cruky serve or you can run dart run --enable-vm-service --disable-service-auth-codes bin/main.dart both are the same. this will run the app in debug mode with hot reload.","title":"Intro"},{"location":"#cruky","text":"Cruky is a server-side library for the dart ecosystem to help you create your API as fast as possible. Cruky team want to make server-side apps with modern style and fast high performance . The main reason why Cruky was built, because all libraries are focused on the Flutter ecosystem and not on dart language and this makes the library have fewer futures than other frameworks or libraries like (Django, FastAPI, ROR, ..etc) So cruky team decided that we will make a new library that focuses on Dart and get the maximum performance using dart mirrors and code generators together to get the best usage of the dart. If you have any idea tell me in discussion section on github Submit new idea Inspired by server-side frameworks like (Django, Flask, FastAPI)","title":"Cruky"},{"location":"#note","text":"This is an early release of Cruky. there may be minor changes in future updates. A few features are still missing that will be part of the 1.0 release. Pub : https://pub.dev/packages/cruky Documentation : https://seifalmotaz.github.io/cruky/ Source Code : https://github.com/seifalmotaz/cruky Issues : https://github.com/seifalmotaz/cruky/issues","title":"Note"},{"location":"#requirements","text":"Install Dart from Dart.dev run dart pub global activate cruky to install cruky executable create project by running cruky create appName Note: if you run cruky and get bash: cruky: command not found error you can do this: try to run cruky.bat create appName if it did not work add C:\\Users\\{{Your name}}\\AppData\\Local\\Pub\\Cache\\bin to your enviroment variables","title":"Requirements"},{"location":"#first-lines","text":"First we must define our main app or the server entry point that have all the routes we use in the app as Cruky recommend to name it MyApp bin/main.dart import 'package:cruky/cruky.dart' ; class MyApp extends ServerApp { @override List get routes => []; @override List get pipeline => []; } We can define two main things the routes getter and pipeline getter: routes used to add the route methods for the app middlewares used to add global middleware for the routes inside this app Second we can add some routes to the main app, we will create a route that response with json and contains a massege: bin/main.dart // rest of code @Route . get ( '/' ) Json getData ( Request req ) { return Json ({ 'msg' : \"Hello world\" }); /// You can use text response too like this Text(\"Hello world\") } We define an annotation first that contains the path then we add a method that handles the request and have a argument called req this argument has type Request that will help you get the request data easily like the (json, form, multipart/form) Now we must add this method to the main app inside the routes getter: bin/main.dart // rest of code class MyApp extends ServerApp { @override List get routes => [ getData , ]; @override List get pipeline => []; } // rest of code Last thing add the main function that will run the app: bin/main.dart void main () => runApp ( MyApp ()); // rest of code Now run the app with command dart pub run cruky serve or you can run dart run --enable-vm-service --disable-service-auth-codes bin/main.dart both are the same. this will run the app in debug mode with hot reload.","title":"First lines"},{"location":"roadmap/","text":"Roadmap Improved how status codes is handled error handling Documentation Add logger Auto generatore OpenAPI/Swagger page inspired from FastAPI Auto client code generatore fron openapi inspired from Serverpod In Future ORM library inspired from Prisma Server CRUD code generator inspired from ROR","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"roadmap/#improved","text":"how status codes is handled error handling Documentation","title":"Improved"},{"location":"roadmap/#add","text":"logger Auto generatore OpenAPI/Swagger page inspired from FastAPI Auto client code generatore fron openapi inspired from Serverpod","title":"Add"},{"location":"roadmap/#in-future","text":"ORM library inspired from Prisma Server CRUD code generator inspired from ROR","title":"In Future"},{"location":"tutorial/routes/","tags":["Route","route","annotation","method handler"],"text":"Route Handlers Route handlers are functions/methods that handle the request with a specific path, and they can have middlewares before it or after. You can respond with the Response class. Usage As we said the method must have a path to knowing what path this method handles so we define Route annotation for the method. Route annotation Main constructor The main constructor has two required arguments and two optional and all of them are positional arguments. const Route ( this . path , // define the method path this . methods , [ // define the accepted methods like \"PUT, POST\" this . middlewares = const [], // adding scoped middlwares this . accepted = const [], // adding the accepted content type request ]); Constructors Some constructors will help you save some time. Name Description get This is a constructor that defines a route with the \"GET\" method post defines a route with the \"POST\" method put defines a route with the \"PUT\" method delete defines a route with the \"DELETE\" method Handler method There are several types of handler methods that you can use we will discuss the basic one on this page. After writing the annotation we define the method under it: @Route . get ( '/my/path' ) Json example ( Request req ) { return Json ({ 'token' : req . data [ 'token' ]}); } As we saw we defined the handler method with path /my/path/ and it responds with Json class that extends Response class. From the req argument you can access some of the request helpers functions like: you can access the JSON body from the request if the request content type is application/json or you can get the form data if content type is application/x-www-form-urlencoded or can get multipart form data if the content type multipart/form-data you can also get the path query data req.query.get('field_name') , and path parameters req.path.get('field_name') and headers req.headerValue('field_name')","title":"Route Handlers"},{"location":"tutorial/routes/#route-handlers","text":"Route handlers are functions/methods that handle the request with a specific path, and they can have middlewares before it or after. You can respond with the Response class.","title":"Route Handlers"},{"location":"tutorial/routes/#usage","text":"As we said the method must have a path to knowing what path this method handles so we define Route annotation for the method.","title":"Usage"},{"location":"tutorial/routes/#route-annotation","text":"","title":"Route annotation"},{"location":"tutorial/routes/#main-constructor","text":"The main constructor has two required arguments and two optional and all of them are positional arguments. const Route ( this . path , // define the method path this . methods , [ // define the accepted methods like \"PUT, POST\" this . middlewares = const [], // adding scoped middlwares this . accepted = const [], // adding the accepted content type request ]);","title":"Main constructor"},{"location":"tutorial/routes/#constructors","text":"Some constructors will help you save some time. Name Description get This is a constructor that defines a route with the \"GET\" method post defines a route with the \"POST\" method put defines a route with the \"PUT\" method delete defines a route with the \"DELETE\" method","title":"Constructors"},{"location":"tutorial/routes/#handler-method","text":"There are several types of handler methods that you can use we will discuss the basic one on this page. After writing the annotation we define the method under it: @Route . get ( '/my/path' ) Json example ( Request req ) { return Json ({ 'token' : req . data [ 'token' ]}); } As we saw we defined the handler method with path /my/path/ and it responds with Json class that extends Response class. From the req argument you can access some of the request helpers functions like: you can access the JSON body from the request if the request content type is application/json or you can get the form data if content type is application/x-www-form-urlencoded or can get multipart form data if the content type multipart/form-data you can also get the path query data req.query.get('field_name') , and path parameters req.path.get('field_name') and headers req.headerValue('field_name')","title":"Handler method"},{"location":"tutorial/apps/app-matrial/","tags":["AppMaterial","pipeline","routes","app material"],"text":"AppMaterial AppMaterial is the main thing that runs the server, it contains the main things that every app needs. Getters Name Type Description prefix String this is a route path prefix that will be added as a prefix to all routes children. routes List here we can define all the method handlers and routes. you simply add the function that has the annotation Route and it will add it to the routes tree. pipeline List here you can add all your middleware to the app and it will be added to all children. Usage Let's make an example. first, we define a class that extends the AppMaterial interface and adds routes and the prefix getter with path \"/example\": class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => []; } Now try to add a new route to the route tree like: class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => [ getData ]; @Route . get ( '/' ) Json getData ( Request req ) { return Text ( \"Hello world\" ); } } Now you can add this app to the routes tree by adding it to the main entry app: import 'package:cruky/cruky.dart' ; void main () => runApp ( MyApp (), debug: true ); class MyApp extends ServerApp { @override List get routes => [ ExampleApp (), ]; } class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => [ example , ]; @Route . get ( '/main' ) Text example ( Request req ) { return Text ( \"Hello world\" ); } } And run the app with dart pub run cruky serve Try to go to localhost:5000/example/main and you will get the Hello world response. Cruky supports nested apps which means you can add an app to the ExampleApp routes and it will have the prefix /example/ and the child app prefix.","title":"AppMaterial"},{"location":"tutorial/apps/app-matrial/#appmaterial","text":"AppMaterial is the main thing that runs the server, it contains the main things that every app needs.","title":"AppMaterial"},{"location":"tutorial/apps/app-matrial/#getters","text":"Name Type Description prefix String this is a route path prefix that will be added as a prefix to all routes children. routes List here we can define all the method handlers and routes. you simply add the function that has the annotation Route and it will add it to the routes tree. pipeline List here you can add all your middleware to the app and it will be added to all children.","title":"Getters"},{"location":"tutorial/apps/app-matrial/#usage","text":"Let's make an example. first, we define a class that extends the AppMaterial interface and adds routes and the prefix getter with path \"/example\": class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => []; } Now try to add a new route to the route tree like: class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => [ getData ]; @Route . get ( '/' ) Json getData ( Request req ) { return Text ( \"Hello world\" ); } } Now you can add this app to the routes tree by adding it to the main entry app: import 'package:cruky/cruky.dart' ; void main () => runApp ( MyApp (), debug: true ); class MyApp extends ServerApp { @override List get routes => [ ExampleApp (), ]; } class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => [ example , ]; @Route . get ( '/main' ) Text example ( Request req ) { return Text ( \"Hello world\" ); } } And run the app with dart pub run cruky serve Try to go to localhost:5000/example/main and you will get the Hello world response. Cruky supports nested apps which means you can add an app to the ExampleApp routes and it will have the prefix /example/ and the child app prefix.","title":"Usage"},{"location":"tutorial/apps/in-app/","tags":["InApp","routes","in app"],"text":"InApp InApp class helps you to add routes to the main app like the AppMaterieal but does not has a routes getter instead you write the route method inside the class. Example class ExampleApp extends InApp { @override String get prefix => '/example' ; @Route . get ( '/' ) getExample ( Request req ) { return Text ( 'InApp example' ); } } Getters Name Type Description prefix String this is a route path prefix that will be added as a prefix to all routes children. pipeline List here you can add all your middleware to the app and it will be added to all children.","title":"InApp"},{"location":"tutorial/apps/in-app/#inapp","text":"InApp class helps you to add routes to the main app like the AppMaterieal but does not has a routes getter instead you write the route method inside the class.","title":"InApp"},{"location":"tutorial/apps/in-app/#example","text":"class ExampleApp extends InApp { @override String get prefix => '/example' ; @Route . get ( '/' ) getExample ( Request req ) { return Text ( 'InApp example' ); } }","title":"Example"},{"location":"tutorial/apps/in-app/#getters","text":"Name Type Description prefix String this is a route path prefix that will be added as a prefix to all routes children. pipeline List here you can add all your middleware to the app and it will be added to all children.","title":"Getters"},{"location":"tutorial/apps/server-app/","tags":["ServerApp","route","server app","method handler"],"text":"ServerApp ServerApp is the main app that the server will get the routes and all things from it like (port, host, routes, middlewares, plugins). This class extends AppMaterial and have the same getters. Getters It has the same AppMaterial getter plus: Name Type Description port String you can define a custom port to use here the default is 5000 address String you can define a custom host to use here the default is 127.0.0.1 plugins List you can add plugins to the app Usage class MyApp extends ServerApp { int get port => 80 ; String get address => '0.0.0.0' ; @override List get routes => [ ExampleApp (), ]; }","title":"ServerApp"},{"location":"tutorial/apps/server-app/#serverapp","text":"ServerApp is the main app that the server will get the routes and all things from it like (port, host, routes, middlewares, plugins). This class extends AppMaterial and have the same getters.","title":"ServerApp"},{"location":"tutorial/apps/server-app/#getters","text":"It has the same AppMaterial getter plus: Name Type Description port String you can define a custom port to use here the default is 5000 address String you can define a custom host to use here the default is 127.0.0.1 plugins List you can add plugins to the app","title":"Getters"},{"location":"tutorial/apps/server-app/#usage","text":"class MyApp extends ServerApp { int get port => 80 ; String get address => '0.0.0.0' ; @override List get routes => [ ExampleApp (), ]; }","title":"Usage"}]}