{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","tags":["cruky","dart","api","API"],"text":"Cruky Cruky is a server-side library for the dart ecosystem to help you create your API as fast as possible. Cruky team want to make server-side apps with modern style and fast high performance . The main reason why Cruky was built, because all libraries are focused on the Flutter ecosystem and not on dart language and this makes the library have fewer futures than other frameworks or libraries like (Django, FastAPI, ROR, ..etc) So cruky team decided that we will make a new library that focuses on Dart and get the maximum performance using dart mirrors and code generators together to get the best usage of the dart. If you have any idea tell me in discussion section on github Submit new idea Inspired by server-side frameworks like (Django, Flask, FastAPI) Danger This is an early release of Cruky. there may be minor changes in future updates. A few features are still missing that will be part of the 1.0 release. Pub : https://pub.dev/packages/cruky Documentation : https://seifalmotaz.github.io/cruky/ Source Code : https://github.com/seifalmotaz/cruky Issues : https://github.com/seifalmotaz/cruky/issues Requirements Install Dart from Dart.dev run dart pub global activate cruky to install cruky executable create project by running cruky create appName Note if you run cruky and get bash: cruky: command not found error you can do this: try to run cruky.bat create appName if it did not work add C:\\Users\\{{Your name}}\\AppData\\Local\\Pub\\Cache\\bin to your enviroment variables First lines First we must define our main app or the server entry point that have all the routes we use in the app as Cruky recommend to name it MyApp bin/main.dart import 'package:cruky/cruky.dart' ; class MyApp extends ServerApp { @override List get routes => []; @override List get pipeline => []; } We can define two main things the routes getter and pipeline getter: routes used to add the route methods for the app middlewares used to add global middleware for the routes inside this app Second we can add some routes to the main app, we will create a route that response with json and contains a massege: bin/main.dart // rest of code @Route . get ( '/' ) Json getData ( Request req ) { return Json ({ 'msg' : \"Hello world\" }); /// You can use text response too like this Text(\"Hello world\") } We define an annotation first that contains the path then we add a method that handles the request and have a argument called req this argument has type Request that will help you get the request data easily like the (json, form, multipart/form) Now we must add this method to the main app inside the routes getter: bin/main.dart // rest of code class MyApp extends ServerApp { @override List get routes => [ getData , ]; @override List get pipeline => []; } // rest of code Last thing add the main function that will run the app: bin/main.dart void main () => runApp ( MyApp ()); // rest of code Now run the app with command dart pub run cruky serve or you can run dart run --enable-vm-service --disable-service-auth-codes bin/main.dart both are the same. this will run the app in debug mode with hot reload.","title":"Intro"},{"location":"#cruky","text":"Cruky is a server-side library for the dart ecosystem to help you create your API as fast as possible. Cruky team want to make server-side apps with modern style and fast high performance . The main reason why Cruky was built, because all libraries are focused on the Flutter ecosystem and not on dart language and this makes the library have fewer futures than other frameworks or libraries like (Django, FastAPI, ROR, ..etc) So cruky team decided that we will make a new library that focuses on Dart and get the maximum performance using dart mirrors and code generators together to get the best usage of the dart. If you have any idea tell me in discussion section on github Submit new idea Inspired by server-side frameworks like (Django, Flask, FastAPI) Danger This is an early release of Cruky. there may be minor changes in future updates. A few features are still missing that will be part of the 1.0 release. Pub : https://pub.dev/packages/cruky Documentation : https://seifalmotaz.github.io/cruky/ Source Code : https://github.com/seifalmotaz/cruky Issues : https://github.com/seifalmotaz/cruky/issues","title":"Cruky"},{"location":"#requirements","text":"Install Dart from Dart.dev run dart pub global activate cruky to install cruky executable create project by running cruky create appName Note if you run cruky and get bash: cruky: command not found error you can do this: try to run cruky.bat create appName if it did not work add C:\\Users\\{{Your name}}\\AppData\\Local\\Pub\\Cache\\bin to your enviroment variables","title":"Requirements"},{"location":"#first-lines","text":"First we must define our main app or the server entry point that have all the routes we use in the app as Cruky recommend to name it MyApp bin/main.dart import 'package:cruky/cruky.dart' ; class MyApp extends ServerApp { @override List get routes => []; @override List get pipeline => []; } We can define two main things the routes getter and pipeline getter: routes used to add the route methods for the app middlewares used to add global middleware for the routes inside this app Second we can add some routes to the main app, we will create a route that response with json and contains a massege: bin/main.dart // rest of code @Route . get ( '/' ) Json getData ( Request req ) { return Json ({ 'msg' : \"Hello world\" }); /// You can use text response too like this Text(\"Hello world\") } We define an annotation first that contains the path then we add a method that handles the request and have a argument called req this argument has type Request that will help you get the request data easily like the (json, form, multipart/form) Now we must add this method to the main app inside the routes getter: bin/main.dart // rest of code class MyApp extends ServerApp { @override List get routes => [ getData , ]; @override List get pipeline => []; } // rest of code Last thing add the main function that will run the app: bin/main.dart void main () => runApp ( MyApp ()); // rest of code Now run the app with command dart pub run cruky serve or you can run dart run --enable-vm-service --disable-service-auth-codes bin/main.dart both are the same. this will run the app in debug mode with hot reload.","title":"First lines"},{"location":"roadmap/","text":"Roadmap Version 1.0.0 Improve how status codes is handled error handling Documentation Add Add web socket Request schema validator from class In Future Features that are added at an unspecified time: ORM library inspired from Prisma Server CRUD code generator inspired from ROR Auto generatore OpenAPI/Swagger page inspired from FastAPI Auto client code generatore from openapi inspired from Serverpod","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"roadmap/#version-100","text":"","title":"Version 1.0.0"},{"location":"roadmap/#improve","text":"how status codes is handled error handling Documentation","title":"Improve"},{"location":"roadmap/#add","text":"Add web socket Request schema validator from class","title":"Add"},{"location":"roadmap/#in-future","text":"Features that are added at an unspecified time: ORM library inspired from Prisma Server CRUD code generator inspired from ROR Auto generatore OpenAPI/Swagger page inspired from FastAPI Auto client code generatore from openapi inspired from Serverpod","title":"In Future"},{"location":"tutorial/path_params/","tags":["path","parameters","path type"],"text":"Path Parameters You can declare path parameters in the Route path string: @Route . get ( '/my/:id' ) Json example ( Request req ) { String myId = req . path [ 'id' ]; return Json ({ 'id' : myId }); } By adding : and the name of the parameter like :id or :name . you can get the parameter data from the path variable in request req.path['parameter'] . Types You can get a specific type of parameter by adding a type validator to the path parameter: @Route . get ( '/my/:id(int)' ) Json example ( Request req ) { int myId = req . path [ 'id' ]; return Json ({ 'id' : myId }); } The default type is a string but there are other types like int , double , num , and string . Note if you set a type for path parameter like the above example if anyone tries to send a request to /my/string will get 404 massage.","title":"Path Parameters"},{"location":"tutorial/path_params/#path-parameters","text":"You can declare path parameters in the Route path string: @Route . get ( '/my/:id' ) Json example ( Request req ) { String myId = req . path [ 'id' ]; return Json ({ 'id' : myId }); } By adding : and the name of the parameter like :id or :name . you can get the parameter data from the path variable in request req.path['parameter'] .","title":"Path Parameters"},{"location":"tutorial/path_params/#types","text":"You can get a specific type of parameter by adding a type validator to the path parameter: @Route . get ( '/my/:id(int)' ) Json example ( Request req ) { int myId = req . path [ 'id' ]; return Json ({ 'id' : myId }); } The default type is a string but there are other types like int , double , num , and string . Note if you set a type for path parameter like the above example if anyone tries to send a request to /my/string will get 404 massage.","title":"Types"},{"location":"tutorial/request_body/","tags":["request","body","content type"],"text":"Request Body You can get the request data by the Request class, it will help you to manipulate the HttpRequest . Json json Request help you to convert the data to Map or List type: @Route . get ( '/' ) Future < Json > example ( Request req ) async { Map body = await req . json (); return Json ( body ); } Info It uses utf8 to decode HttpRequest stream. Form x-www-form-urlencoded @Route . get ( '/' ) Future < Text > example ( Request req ) async { FormData body = await req . form (); print ( body [ 'data' ]) // print List<String> print ( body . getInt ( 'data' )) // print int print ( body . listInt ( 'data' )) // print List<int> return Text ( 'ok' ); } This method will help you to get the form data as Map<String, List<String>> so you can get the data by body['data'] bu if you want to get the data with spacific type like int you can use body.getInt('data') or you can get a list of int by body.listInt('data') . Multipart form multipart/form-data It has the same options that in FormData and formFiles variable that contains a list of FilePart : @Route . get ( '/' ) Future < Text > example ( Request req ) async { iFormData body = await req . iForm (); print ( body . formFiles ); // print Map<String, List<FilePart>> print ( body [ 'data' ]) // print List<String> print ( body . getInt ( 'data' )) // print int print ( body . listInt ( 'data' )) // print List<int> print ( body [ 'file' ]) // print List<FilePart> print ( body . getFile ( 'file' )) // print FilePart return Text ( 'ok' ); }","title":"Request Body"},{"location":"tutorial/request_body/#request-body","text":"You can get the request data by the Request class, it will help you to manipulate the HttpRequest .","title":"Request Body"},{"location":"tutorial/request_body/#json-json","text":"Request help you to convert the data to Map or List type: @Route . get ( '/' ) Future < Json > example ( Request req ) async { Map body = await req . json (); return Json ( body ); } Info It uses utf8 to decode HttpRequest stream.","title":"Json json"},{"location":"tutorial/request_body/#form-x-www-form-urlencoded","text":"@Route . get ( '/' ) Future < Text > example ( Request req ) async { FormData body = await req . form (); print ( body [ 'data' ]) // print List<String> print ( body . getInt ( 'data' )) // print int print ( body . listInt ( 'data' )) // print List<int> return Text ( 'ok' ); } This method will help you to get the form data as Map<String, List<String>> so you can get the data by body['data'] bu if you want to get the data with spacific type like int you can use body.getInt('data') or you can get a list of int by body.listInt('data') .","title":"Form x-www-form-urlencoded"},{"location":"tutorial/request_body/#multipart-form-multipartform-data","text":"It has the same options that in FormData and formFiles variable that contains a list of FilePart : @Route . get ( '/' ) Future < Text > example ( Request req ) async { iFormData body = await req . iForm (); print ( body . formFiles ); // print Map<String, List<FilePart>> print ( body [ 'data' ]) // print List<String> print ( body . getInt ( 'data' )) // print int print ( body . listInt ( 'data' )) // print List<int> print ( body [ 'file' ]) // print List<FilePart> print ( body . getFile ( 'file' )) // print FilePart return Text ( 'ok' ); }","title":"Multipart form multipart/form-data"},{"location":"tutorial/routes/","tags":["Route","route","annotation","method handler"],"text":"Route Handlers Route handlers are functions/methods that handle the request with a specific path, and they can have middlewares before it or after. You can respond with the Response class. Usage As we said the method must have a path to knowing what path this method handles so we define Route annotation for the method. Route annotation Main constructor The main constructor has two required arguments and two optional and all of them are positional arguments. const Route ( this . path , // define the method path this . methods , [ // define the accepted methods like \"PUT, POST\" this . middlewares = const [], // adding scoped middlwares this . accepted = const [], // adding the accepted content type request ]); Constructors Some constructors will help you save some time. Name Description get This is a constructor that defines a route with the \"GET\" method post defines a route with the \"POST\" method put defines a route with the \"PUT\" method delete defines a route with the \"DELETE\" method Handler method There are several types of handler methods that you can use we will discuss the basic one on this page. After writing the annotation we define the method under it: @Route . get ( '/my/path' ) Json example ( Request req ) { return Json ({}); } As we saw we defined the handler method with path /my/path/ and it responds with Json class that extends Response class. From the req argument you can access some of the request helpers functions like: you can access the JSON body from the request if the request content type is application/json or you can get the form data if content type is application/x-www-form-urlencoded or can get multipart form data if the content type multipart/form-data you can also get the path query data req.query.get('field_name') , and path parameters req.path.get('field_name') and headers req.headerValue('field_name')","title":"Route Handlers"},{"location":"tutorial/routes/#route-handlers","text":"Route handlers are functions/methods that handle the request with a specific path, and they can have middlewares before it or after. You can respond with the Response class.","title":"Route Handlers"},{"location":"tutorial/routes/#usage","text":"As we said the method must have a path to knowing what path this method handles so we define Route annotation for the method.","title":"Usage"},{"location":"tutorial/routes/#route-annotation","text":"","title":"Route annotation"},{"location":"tutorial/routes/#main-constructor","text":"The main constructor has two required arguments and two optional and all of them are positional arguments. const Route ( this . path , // define the method path this . methods , [ // define the accepted methods like \"PUT, POST\" this . middlewares = const [], // adding scoped middlwares this . accepted = const [], // adding the accepted content type request ]);","title":"Main constructor"},{"location":"tutorial/routes/#constructors","text":"Some constructors will help you save some time. Name Description get This is a constructor that defines a route with the \"GET\" method post defines a route with the \"POST\" method put defines a route with the \"PUT\" method delete defines a route with the \"DELETE\" method","title":"Constructors"},{"location":"tutorial/routes/#handler-method","text":"There are several types of handler methods that you can use we will discuss the basic one on this page. After writing the annotation we define the method under it: @Route . get ( '/my/path' ) Json example ( Request req ) { return Json ({}); } As we saw we defined the handler method with path /my/path/ and it responds with Json class that extends Response class. From the req argument you can access some of the request helpers functions like: you can access the JSON body from the request if the request content type is application/json or you can get the form data if content type is application/x-www-form-urlencoded or can get multipart form data if the content type multipart/form-data you can also get the path query data req.query.get('field_name') , and path parameters req.path.get('field_name') and headers req.headerValue('field_name')","title":"Handler method"},{"location":"tutorial/schema_validator/","tags":["schema","validator"],"text":"Schema Validator Cruky has a schema validator option that can help you get the data from the request body and make sure that the data sent is in the correct spelling: class Todo { String task ; bool isCompleted ; Todo ( this . task , this . isCompleted ); } To turn this class into a schema we must add a Schema annotation to define from where to get this data and add a parse constructor: @Schema . json () class Todo { final String task ; final bool isCompleted ; Todo . parse ( this . task , this . isCompleted ); } and add it to the route handler: @Route . get ( '/' ) Map example ( Request req , Todo todo ) { return { \"task\" : todo . task , \"is_completed\" : todo . isCompleted , }; } It will get the JSON body data and accept only the application/json content type. Note You can only have one schema validator for this handler type. Do not forget to add the parse constructor. In the parse constructor cruky accept both positioned and named arguments.","title":"Schema Validator"},{"location":"tutorial/schema_validator/#schema-validator","text":"Cruky has a schema validator option that can help you get the data from the request body and make sure that the data sent is in the correct spelling: class Todo { String task ; bool isCompleted ; Todo ( this . task , this . isCompleted ); } To turn this class into a schema we must add a Schema annotation to define from where to get this data and add a parse constructor: @Schema . json () class Todo { final String task ; final bool isCompleted ; Todo . parse ( this . task , this . isCompleted ); } and add it to the route handler: @Route . get ( '/' ) Map example ( Request req , Todo todo ) { return { \"task\" : todo . task , \"is_completed\" : todo . isCompleted , }; } It will get the JSON body data and accept only the application/json content type. Note You can only have one schema validator for this handler type. Do not forget to add the parse constructor. In the parse constructor cruky accept both positioned and named arguments.","title":"Schema Validator"},{"location":"tutorial/apps/app-matrial/","tags":["AppMaterial","pipeline","routes","app material"],"text":"AppMaterial AppMaterial is the main thing that runs the server, it contains the main things that every app needs. Getters Name Type Description prefix String this is a route path prefix that will be added as a prefix to all routes children. routes List here we can define all the method handlers and routes. you simply add the function that has the annotation Route and it will add it to the routes tree. pipeline List here you can add all your middleware to the app and it will be added to all children. Usage Let's make an example. first, we define a class that extends the AppMaterial interface and adds routes and the prefix getter with path \"/example\": class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => []; } Now try to add a new route to the route tree like: class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => [ getData ]; @Route . get ( '/' ) Json getData ( Request req ) { return Text ( \"Hello world\" ); } } Now you can add this app to the routes tree by adding it to the main entry app: import 'package:cruky/cruky.dart' ; void main () => runApp ( MyApp (), debug: true ); class MyApp extends ServerApp { @override List get routes => [ ExampleApp (), ]; } class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => [ example , ]; @Route . get ( '/main' ) Text example ( Request req ) { return Text ( \"Hello world\" ); } } And run the app with dart pub run cruky serve Try to go to localhost:5000/example/main and you will get the Hello world response. Cruky supports nested apps which means you can add an app to the ExampleApp routes and it will have the prefix /example/ and the child app prefix.","title":"AppMaterial"},{"location":"tutorial/apps/app-matrial/#appmaterial","text":"AppMaterial is the main thing that runs the server, it contains the main things that every app needs.","title":"AppMaterial"},{"location":"tutorial/apps/app-matrial/#getters","text":"Name Type Description prefix String this is a route path prefix that will be added as a prefix to all routes children. routes List here we can define all the method handlers and routes. you simply add the function that has the annotation Route and it will add it to the routes tree. pipeline List here you can add all your middleware to the app and it will be added to all children.","title":"Getters"},{"location":"tutorial/apps/app-matrial/#usage","text":"Let's make an example. first, we define a class that extends the AppMaterial interface and adds routes and the prefix getter with path \"/example\": class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => []; } Now try to add a new route to the route tree like: class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => [ getData ]; @Route . get ( '/' ) Json getData ( Request req ) { return Text ( \"Hello world\" ); } } Now you can add this app to the routes tree by adding it to the main entry app: import 'package:cruky/cruky.dart' ; void main () => runApp ( MyApp (), debug: true ); class MyApp extends ServerApp { @override List get routes => [ ExampleApp (), ]; } class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => [ example , ]; @Route . get ( '/main' ) Text example ( Request req ) { return Text ( \"Hello world\" ); } } And run the app with dart pub run cruky serve Try to go to localhost:5000/example/main and you will get the Hello world response. Cruky supports nested apps which means you can add an app to the ExampleApp routes and it will have the prefix /example/ and the child app prefix.","title":"Usage"},{"location":"tutorial/apps/in-app/","tags":["InApp","routes","in app"],"text":"InApp InApp class helps you to add routes to the main app like the AppMaterieal but does not has a routes getter instead you write the route method inside the class. Example class ExampleApp extends InApp { @override String get prefix => '/example' ; @Route . get ( '/' ) getExample ( Request req ) { return Text ( 'InApp example' ); } } Getters Name Type Description prefix String this is a route path prefix that will be added as a prefix to all routes children. pipeline List here you can add all your middleware to the app and it will be added to all children.","title":"InApp"},{"location":"tutorial/apps/in-app/#inapp","text":"InApp class helps you to add routes to the main app like the AppMaterieal but does not has a routes getter instead you write the route method inside the class.","title":"InApp"},{"location":"tutorial/apps/in-app/#example","text":"class ExampleApp extends InApp { @override String get prefix => '/example' ; @Route . get ( '/' ) getExample ( Request req ) { return Text ( 'InApp example' ); } }","title":"Example"},{"location":"tutorial/apps/in-app/#getters","text":"Name Type Description prefix String this is a route path prefix that will be added as a prefix to all routes children. pipeline List here you can add all your middleware to the app and it will be added to all children.","title":"Getters"},{"location":"tutorial/apps/server-app/","tags":["ServerApp","route","server app","method handler"],"text":"ServerApp ServerApp is the main app that the server will get the routes and all things from it like (port, host, routes, middlewares, plugins). This class extends AppMaterial and have the same getters. Getters It has the same AppMaterial getter plus: Name Type Description port String you can define a custom port to use here the default is 5000 address String you can define a custom host to use here the default is 127.0.0.1 plugins List you can add plugins to the app Usage class MyApp extends ServerApp { int get port => 80 ; String get address => '0.0.0.0' ; @override List get routes => [ ExampleApp (), ]; }","title":"ServerApp"},{"location":"tutorial/apps/server-app/#serverapp","text":"ServerApp is the main app that the server will get the routes and all things from it like (port, host, routes, middlewares, plugins). This class extends AppMaterial and have the same getters.","title":"ServerApp"},{"location":"tutorial/apps/server-app/#getters","text":"It has the same AppMaterial getter plus: Name Type Description port String you can define a custom port to use here the default is 5000 address String you can define a custom host to use here the default is 127.0.0.1 plugins List you can add plugins to the app","title":"Getters"},{"location":"tutorial/apps/server-app/#usage","text":"class MyApp extends ServerApp { int get port => 80 ; String get address => '0.0.0.0' ; @override List get routes => [ ExampleApp (), ]; }","title":"Usage"}]}