{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cruky Cruky is a server-side library for the dart ecosystem to help you create your API as fast as possible. We want to make server-side apps with modern style and fast high performance . The main reason why Cruky is built this is that all libraries are focused on the Flutter ecosystem and not on dart lang and this makes the library have fewer futures than other frameworks or libraries like (Django, FastAPI, ROR, ..etc) So I decided that I will make a new library that focuses on Dart and get the maximum performance using dart:mirrors and code generators together to get the best usage of the dart. Inspired by server-side frameworks like (Django, Flask, FastAPI, ROR) This is all frameworks that I learned. Documentation : https://seifalmotaz.github.io/cruky/ Source Code : https://github.com/seifalmotaz/cruky Issues : https://github.com/seifalmotaz/cruky/issues Requirements Install Dart from Dart.dev run command dart pub global activate cruky Create new dart project Install cruky https://pub.dev/packages/cruky create main.dart file in bin directory and you ready to write your app First lines First we must define our main app or the server entry point that have all the routes we use in the app as Cruky recommend to name it MyApp bin/main.dart import 'package:cruky/cruky.dart' ; class MyApp extends ServerApp { @override List get routes => []; @override List get pipeline => []; } We can define two main things the routes getter and pipeline getter: routes used to add the route methods for the app middlewares used to add global middleware for the routes inside this app Second we can add some routes to the main app, we will create a route that response with json and contains a massege: bin/main.dart // rest of code @Route . get ( '/' ) Json getData ( Request req ) { return Json ({ 'msg' : \"Hello world\" }); /// You can use text response too like this Text(\"Hello world\") } We define an annotation first that contains the path then we add a method that handles the request and have a argument called req this argument has type Request that will help you get the request data easily like the (json, form, multipart/form) Now we must add this method to the main app inside the routes getter: bin/main.dart // rest of code class MyApp extends ServerApp { @override List get routes => [ getData , ]; @override List get pipeline => []; } // rest of code Last thing add the main function that will run the app: bin/main.dart void main () => runApp ( MyApp ()); // rest of code Now run the app with command dart pub run cruky serve or you can run dart run --enable-vm-service --disable-service-auth-codes bin/main.dart both are the same. this will run the app in debug mode with hot reload.","title":"Intro"},{"location":"#cruky","text":"Cruky is a server-side library for the dart ecosystem to help you create your API as fast as possible. We want to make server-side apps with modern style and fast high performance . The main reason why Cruky is built this is that all libraries are focused on the Flutter ecosystem and not on dart lang and this makes the library have fewer futures than other frameworks or libraries like (Django, FastAPI, ROR, ..etc) So I decided that I will make a new library that focuses on Dart and get the maximum performance using dart:mirrors and code generators together to get the best usage of the dart. Inspired by server-side frameworks like (Django, Flask, FastAPI, ROR) This is all frameworks that I learned. Documentation : https://seifalmotaz.github.io/cruky/ Source Code : https://github.com/seifalmotaz/cruky Issues : https://github.com/seifalmotaz/cruky/issues","title":"Cruky"},{"location":"#requirements","text":"Install Dart from Dart.dev run command dart pub global activate cruky Create new dart project Install cruky https://pub.dev/packages/cruky create main.dart file in bin directory and you ready to write your app","title":"Requirements"},{"location":"#first-lines","text":"First we must define our main app or the server entry point that have all the routes we use in the app as Cruky recommend to name it MyApp bin/main.dart import 'package:cruky/cruky.dart' ; class MyApp extends ServerApp { @override List get routes => []; @override List get pipeline => []; } We can define two main things the routes getter and pipeline getter: routes used to add the route methods for the app middlewares used to add global middleware for the routes inside this app Second we can add some routes to the main app, we will create a route that response with json and contains a massege: bin/main.dart // rest of code @Route . get ( '/' ) Json getData ( Request req ) { return Json ({ 'msg' : \"Hello world\" }); /// You can use text response too like this Text(\"Hello world\") } We define an annotation first that contains the path then we add a method that handles the request and have a argument called req this argument has type Request that will help you get the request data easily like the (json, form, multipart/form) Now we must add this method to the main app inside the routes getter: bin/main.dart // rest of code class MyApp extends ServerApp { @override List get routes => [ getData , ]; @override List get pipeline => []; } // rest of code Last thing add the main function that will run the app: bin/main.dart void main () => runApp ( MyApp ()); // rest of code Now run the app with command dart pub run cruky serve or you can run dart run --enable-vm-service --disable-service-auth-codes bin/main.dart both are the same. this will run the app in debug mode with hot reload.","title":"First lines"},{"location":"basics/app-matrial/","text":"App Matrial AppMaterial is the main thing that runs the server, it contains the main things that every app need. Getters Name Type Discription prefix String this is a route path prefix that will be added as prefix to all routes children. routes List here we can define all the method handlers and routes. you simply add the function the has the annotation Route and it will add it to the routes tree. middlwares List this is a route path prefix that will be added as prefix to all routes children. Usage Let's make an example. first we define a class that extends the AppMaterial interface and adding routes and the prefix getter with path \"/example\": class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => []; } Now try to add a new route to the route tree like: class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => [ getData ]; @Route . get ( '/' ) Json getData ( Request req ) { return Text ( \"Hello world\" ); } } Now you can add this app to the routes tree with adding it to the main entry app: import 'package:cruky/cruky.dart' ; void main () => runApp ( MyApp (), debug: true ); class MyApp extends ServerApp { @override List get routes => [ ExampleApp (), ]; } class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => [ example , ]; @Route . get ( '/main' ) Text example ( Request req ) { return Text ( \"Hello world\" ); } } And run the app with dart pub run cruky serve Try to go to localhost:5000/example/main and you will get the Hello world response. Cruky supports nested apps that means you can add an app to the ExampleApp routes and it will have the prefix /example/ and the child app prefix.","title":"App Matrial"},{"location":"basics/app-matrial/#app-matrial","text":"AppMaterial is the main thing that runs the server, it contains the main things that every app need.","title":"App Matrial"},{"location":"basics/app-matrial/#getters","text":"Name Type Discription prefix String this is a route path prefix that will be added as prefix to all routes children. routes List here we can define all the method handlers and routes. you simply add the function the has the annotation Route and it will add it to the routes tree. middlwares List this is a route path prefix that will be added as prefix to all routes children.","title":"Getters"},{"location":"basics/app-matrial/#usage","text":"Let's make an example. first we define a class that extends the AppMaterial interface and adding routes and the prefix getter with path \"/example\": class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => []; } Now try to add a new route to the route tree like: class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => [ getData ]; @Route . get ( '/' ) Json getData ( Request req ) { return Text ( \"Hello world\" ); } } Now you can add this app to the routes tree with adding it to the main entry app: import 'package:cruky/cruky.dart' ; void main () => runApp ( MyApp (), debug: true ); class MyApp extends ServerApp { @override List get routes => [ ExampleApp (), ]; } class ExampleApp extends AppMaterial { @override String get prefix => '/example/' ; @override List get routes => [ example , ]; @Route . get ( '/main' ) Text example ( Request req ) { return Text ( \"Hello world\" ); } } And run the app with dart pub run cruky serve Try to go to localhost:5000/example/main and you will get the Hello world response. Cruky supports nested apps that means you can add an app to the ExampleApp routes and it will have the prefix /example/ and the child app prefix.","title":"Usage"},{"location":"basics/routes/","text":"Route Handlers Route handlers are functions/methods that handle the request with a specific path, and they can have middlewares before it or after. You can respond with the Response class. Usage As we said the method must have a path to knowing what path this method handles so we define Route annotation for the method. Route annotation Main constructor The main constructor has two required arguments and two optional and all of them are positional arguments. const Route ( this . path , // define the method path this . methods , [ // define the accepted methods like \"PUT, POST\" this . middlewares = const [], // adding scoped middlwares this . accepted = const [], // adding the accepted content type request ]); Constructors Some constructors will help you save some time. The first constructors are the methods helper: Name Description get This is a constructor that defines a route with the \"GET\" method post defines a route with the \"POST\" method put defines a route with the \"PUT\" method delete defines a route with the \"DELETE\" method The second constructors are the methods and content type helper: constructors that have JSON content type in the accepted arg Name Description jget This is a constructor that defines a route with the \"GET\" method jpost defines a route with the \"POST\" method jput defines a route with the \"PUT\" method jdelete defines a route with the \"DELETE\" method Handler method There are several types of handler methods that you can use we will discuss the basic one on this page. After writing the annotation we define the method under it: @Route . get ( '/my/path' ) Json example ( Request req ) { return Json ({ 'token' : req . data [ 'token' ]}); } As we saw we defined the handler method with path /my/path/ and it responds with Json class that extends Response class. From the req argument you can access some of the request helpers functions like: you can access the JSON body from the request if the request content type is application/json or you can get the form data if content type is application/x-www-form-urlencoded or can get multipart form data if the content type multipart/form-data you can also get the path query data req.query.get('field_name') , and path parameters req.path.get('field_name') and headers req.headerValue('field_name')","title":"Route Handlers"},{"location":"basics/routes/#route-handlers","text":"Route handlers are functions/methods that handle the request with a specific path, and they can have middlewares before it or after. You can respond with the Response class.","title":"Route Handlers"},{"location":"basics/routes/#usage","text":"As we said the method must have a path to knowing what path this method handles so we define Route annotation for the method.","title":"Usage"},{"location":"basics/routes/#route-annotation","text":"","title":"Route annotation"},{"location":"basics/routes/#main-constructor","text":"The main constructor has two required arguments and two optional and all of them are positional arguments. const Route ( this . path , // define the method path this . methods , [ // define the accepted methods like \"PUT, POST\" this . middlewares = const [], // adding scoped middlwares this . accepted = const [], // adding the accepted content type request ]);","title":"Main constructor"},{"location":"basics/routes/#constructors","text":"Some constructors will help you save some time. The first constructors are the methods helper: Name Description get This is a constructor that defines a route with the \"GET\" method post defines a route with the \"POST\" method put defines a route with the \"PUT\" method delete defines a route with the \"DELETE\" method The second constructors are the methods and content type helper: constructors that have JSON content type in the accepted arg Name Description jget This is a constructor that defines a route with the \"GET\" method jpost defines a route with the \"POST\" method jput defines a route with the \"PUT\" method jdelete defines a route with the \"DELETE\" method","title":"Constructors"},{"location":"basics/routes/#handler-method","text":"There are several types of handler methods that you can use we will discuss the basic one on this page. After writing the annotation we define the method under it: @Route . get ( '/my/path' ) Json example ( Request req ) { return Json ({ 'token' : req . data [ 'token' ]}); } As we saw we defined the handler method with path /my/path/ and it responds with Json class that extends Response class. From the req argument you can access some of the request helpers functions like: you can access the JSON body from the request if the request content type is application/json or you can get the form data if content type is application/x-www-form-urlencoded or can get multipart form data if the content type multipart/form-data you can also get the path query data req.query.get('field_name') , and path parameters req.path.get('field_name') and headers req.headerValue('field_name')","title":"Handler method"},{"location":"basics/server-app/","text":"Server App ServerApp is the main app that the server will get the routes and all things from it like (port, host, routes, middlewares, plugins). This class extends AppMaterial and have the same getters. Getters It has the same AppMaterial getter plus: Name Type Discription port String you can define a custom port to use here the default is 5000 address String you can define a custom host to use here the default is 127.0.0.1 plugins List you can add plugins to the app Usage class MyApp extends ServerApp { int get port => 80 ; String get address => '0.0.0.0' ; @override List get routes => [ ExampleApp (), ]; }","title":"Server App"},{"location":"basics/server-app/#server-app","text":"ServerApp is the main app that the server will get the routes and all things from it like (port, host, routes, middlewares, plugins). This class extends AppMaterial and have the same getters.","title":"Server App"},{"location":"basics/server-app/#getters","text":"It has the same AppMaterial getter plus: Name Type Discription port String you can define a custom port to use here the default is 5000 address String you can define a custom host to use here the default is 127.0.0.1 plugins List you can add plugins to the app","title":"Getters"},{"location":"basics/server-app/#usage","text":"class MyApp extends ServerApp { int get port => 80 ; String get address => '0.0.0.0' ; @override List get routes => [ ExampleApp (), ]; }","title":"Usage"}]}